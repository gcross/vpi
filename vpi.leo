<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.344827586207">
	<global_window_position top="73" left="43" height="783" width="1219"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="gcross.20090807144330.1670" str_leo_pos="5,0"><vh>@chapters</vh></v>
<v t="gcross.20090624144408.1779"><vh>Potentials</vh>
<v t="gcross.20090624094338.1366"><vh>@path src/potentials/single_particle</vh>
<v t="gcross.20090624144408.1411"><vh>@thin sp_null_potential.f90</vh></v>
<v t="gcross.20090624144408.1889"><vh>Boxes</vh>
<v t="gcross.20090624094338.1367"><vh>@thin sp_rectangular_box_potential.f90</vh></v>
<v t="gcross.20090624094338.1381"><vh>@thin sp_cylindrical_box_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1890"><vh>Harmonic oscillators</vh>
<v t="gcross.20090624094338.1396"><vh>@thin sp_harmonic_oscillator_1D_potential.f90</vh></v>
<v t="gcross.20090624094338.1410"><vh>@thin sp_harmonic_oscillator_3D_potential.f90</vh></v>
<v t="gcross.20090624094338.1424"><vh>@thin sp_harmonic_oscillator_overlapping_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1426"><vh>@thin sp_wlink_potential.f90</vh></v>
<v t="gcross.20090624144408.1441"><vh>@thin sp_morse_oscillator_potential.f90</vh></v>
<v t="gcross.20090624144408.1891"><vh>Wells</vh>
<v t="gcross.20090624144408.1455"><vh>@thin sp_G_well_potential.f90</vh></v>
<v t="gcross.20090624144408.1471"><vh>@thin sp_D_well_potential.f90</vh></v>
<v t="gcross.20090624144408.1485"><vh>@thin sp_N_well_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1892"><vh>Annulus</vh>
<v t="gcross.20090624144408.1500"><vh>@thin sp_annulus_common.f90</vh></v>
<v t="gcross.20090624144408.1512"><vh>@thin sp_annulus_version_1_potential.f90</vh></v>
<v t="gcross.20090624144408.1523"><vh>@thin sp_annulus_version_2_potential.f90</vh></v>
<v t="gcross.20090624144408.1533"><vh>@thin sp_annulus_version_3_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1893"><vh>Atomic</vh>
<v t="gcross.20090624144408.1559"><vh>@thin sp_atomic_potential.f90</vh></v>
<v t="gcross.20090624144408.1573"><vh>@thin sp_atomic_overlapping_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1894"><vh>Lattice</vh>
<v t="gcross.20090624144408.1587"><vh>@thin sp_lattice_2D_with_HO_potential.f90</vh></v>
<v t="gcross.20090624144408.1601"><vh>@thin sp_lattice_3D_with_HO_potential.f90</vh></v>
</v>
</v>
<v t="gcross.20090624144408.1608"><vh>@path src/potentials/two_body</vh>
<v t="gcross.20090624144408.1630"><vh>@thin tb_null_potential.f90</vh></v>
<v t="gcross.20090624144408.1644"><vh>@thin tb_charge_potential.f90</vh></v>
<v t="gcross.20090624144408.1672"><vh>@thin tb_lj_potential.f90</vh></v>
<v t="gcross.20090624144408.1686"><vh>@thin tb_sa_potential.f90</vh></v>
<v t="gcross.20090624144408.1700"><vh>@thin tb_sc_potential.f90</vh></v>
<v t="gcross.20090624144408.1714"><vh>@thin tb_hard_sphere_potential.f90</vh></v>
<v t="gcross.20090624144408.1729"><vh>@thin tb_dimer_Z_polarized_potential.f90</vh></v>
<v t="gcross.20090624144408.1743"><vh>@thin tb_dimer_Z_polarized_with_hard_sphere_potential.f90</vh></v>
</v>
<v t="gcross.20090624144408.1750"><vh>@path src/potentials/rotational</vh>
<v t="gcross.20090624144408.1758"><vh>@thin rot_dimer_potential.f90</vh></v>
<v t="gcross.20090624144408.1772"><vh>@thin rot_undefined_potential.f90</vh></v>
</v>
</v>
<v t="gcross.20090624144408.1780"><vh>Trial functions</vh>
<v t="gcross.20090624144408.1783"><vh>@path src/trials/single_particle</vh>
<v t="gcross.20090624144408.1973"><vh>@thin sp_trial_numeric_differentiator.f90</vh></v>
<v t="gcross.20090624144408.1791"><vh>@thin sp_atomic_trial.f90</vh></v>
<v t="gcross.20090624144408.1809"><vh>@thin sp_He3plus_trial.f90</vh></v>
<v t="gcross.20090624144408.1838"><vh>@thin sp_box_trial.f90</vh></v>
<v t="gcross.20090624144408.1852"><vh>@thin sp_harmonic_3D_trial.f90</vh></v>
<v t="gcross.20090624144408.1866"><vh>@thin sp_anharmonic_trial.f90</vh></v>
<v t="gcross.20090624144408.1895"><vh>Morse</vh>
<v t="gcross.20090624144408.1904"><vh>@thin sp_morse_trial_common.f90</vh></v>
<v t="gcross.20090624144408.1882"><vh>@thin sp_morse_version_1_trial.f90</vh></v>
<v t="gcross.20090624144408.1917"><vh>@thin sp_morse_version_2_trial.f90</vh></v>
</v>
<v t="gcross.20090624144408.1924"><vh>D Well</vh>
<v t="gcross.20090624144408.1931"><vh>@thin sp_D_well_trial_common.f90</vh></v>
<v t="gcross.20090624144408.1941"><vh>@thin sp_D_well_version_1_trial.f90</vh></v>
<v t="gcross.20090624144408.1953"><vh>@thin sp_D_well_version_2_trial.f90</vh></v>
</v>
<v t="gcross.20090624144408.1966"><vh>@thin sp_N_well_trial.f90</vh></v>
<v t="gcross.20090624144408.1981"><vh>@thin sp_lattice_trial.f90</vh></v>
</v>
<v t="gcross.20090624144408.1988"><vh>@path src/trials/jastrow</vh>
<v t="gcross.20090623152316.102"><vh>@thin jas_trial_numeric_differentiator.f90</vh></v>
<v t="gcross.20090624144408.1996"><vh>@thin jas_hard_sphere_trial.f90</vh></v>
<v t="gcross.20090624144408.2010"><vh>@thin jas_lj_trial.f90</vh></v>
<v t="gcross.20090624144408.2024"><vh>@thin jas_charge_trial.f90</vh></v>
<v t="gcross.20090624144408.2038"><vh>@thin jas_independent_trial.f90</vh></v>
</v>
</v>
<v t="gcross.20090623152316.2"><vh>@path src</vh>
<v t="gcross.20090806151612.1842"><vh>@thin Makefile</vh></v>
<v t="gcross.20090624144408.1462"><vh>@thin constants.f90</vh></v>
<v t="gcross.20090807144330.2245"><vh>@thin angular_momentum.f95</vh></v>
<v t="gcross.20090623152316.73"><vh>@thin sample.f90</vh></v>
<v t="gcross.20090812093015.1722"><vh>@thin gfn.f95</vh></v>
<v t="gcross.20090805153643.1852"><vh>@thin rand_utils.f90</vh></v>
<v t="gcross.20090805093617.1832"><vh>@thin xij.f95</vh></v>
<v t="gcross.20090805153643.1843"><vh>@thin thermalize.f90</vh></v>
<v t="gcross.20090806151612.1841"><vh>@thin timers.f90</vh></v>
<v t="gcross.20090807144330.1675"><vh>@thin test.py</vh></v>
</v>
<v t="gcross.20090807144330.1673"><vh>@path src/tests</vh>
<v t="gcross.20090807144330.1674"><vh>@thin __init__.py</vh></v>
<v t="gcross.20090807144330.2253"><vh>@thin angular_momentum.py</vh></v>
<v t="gcross.20090806151612.1843"><vh>@thin xij.py</vh></v>
<v t="gcross.20090812093015.1742"><vh>@thin gfn.py</vh></v>
<v t="gcross.20090807144330.2151"><vh>@thin thermalize.py</vh></v>
</v>
<v t="gcross.20090809223137.1725" a="E"><vh>Pythonize Project</vh>
<v t="gcross.20090809223137.1726" a="E"><vh>@path src</vh>
<v t="gcross.20090805153643.1843"></v>
</v>
<v t="gcross.20090721121051.1746"><vh>compute_log_acceptance_weight</vh>
<v t="gcross.20090626112946.1696"><vh>&lt;&lt; Compute contribution from potentials &gt;&gt;</vh></v>
<v t="gcross.20090721121051.1752"><vh>&lt;&lt; Compute contribution from propagators &gt;&gt;</vh></v>
<v t="gcross.20090721121051.1754"><vh>&lt;&lt; Compute contribution from trial functions &gt;&gt;</vh></v>
</v>
<v t="gcross.20090626112946.1694"><vh>thermalize_path</vh>
<v t="gcross.20090805153643.1848"><vh>&lt;&lt; Initialize trial functions &gt;&gt;</vh></v>
<v t="gcross.20090626112946.1688"><vh>&lt;&lt; Randomly choose a move to make and apply it to the system &gt;&gt;</vh>
<v t="gcross.20090626112946.1691"><vh>&lt;&lt; Impose periodic boundary conditions &gt;&gt;</vh></v>
<v t="gcross.20090626112946.1690"><vh>&lt;&lt; Update move type statistics &gt;&gt;</vh></v>
<v t="gcross.20090626112946.1689"><vh>&lt;&lt; Update the displacement matrix &gt;&gt;</vh></v>
</v>
<v t="gcross.20090626112946.1693"><vh>&lt;&lt; Determine whether the move should be accepted &gt;&gt;</vh>
<v t="gcross.20090721121051.1755"><vh>&lt;&lt; Compute logarithmic probability of acceptance &gt;&gt;</vh></v>
<v t="gcross.20090626112946.1706"><vh>&lt;&lt; Accept or reject the move &gt;&gt;</vh>
<v t="gcross.20090626112946.1701"><vh>&lt;&lt; Update the degrees of freedom &gt;&gt;</vh></v>
<v t="gcross.20090805093617.1831"><vh>&lt;&lt; Update derived quantities &gt;&gt;</vh></v>
<v t="gcross.20090626112946.1703"><vh>&lt;&lt; Update statistics &gt;&gt;</vh></v>
</v>
</v>
<v t="gcross.20090805093617.1835"><vh>subroutine revert_move</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="gcross.20090623152316.2">@tabwidth -2
</t>
<t tx="gcross.20090624094338.1366"></t>
<t tx="gcross.20090624144408.1608"></t>
<t tx="gcross.20090624144408.1750"></t>
<t tx="gcross.20090624144408.1779"></t>
<t tx="gcross.20090624144408.1780"></t>
<t tx="gcross.20090624144408.1783"></t>
<t tx="gcross.20090624144408.1889"></t>
<t tx="gcross.20090624144408.1890"></t>
<t tx="gcross.20090624144408.1891"></t>
<t tx="gcross.20090624144408.1892"></t>
<t tx="gcross.20090624144408.1893"></t>
<t tx="gcross.20090624144408.1894"></t>
<t tx="gcross.20090624144408.1895"></t>
<t tx="gcross.20090624144408.1924"></t>
<t tx="gcross.20090624144408.1988"></t>
<t tx="gcross.20090626112946.1688">call sample_scheme1(q, q_trial, move_start, move_end, part_num, mtype)
if( present(q_rot) ) then
  call sample_rotation(q_rot, q_rot_trial, move_start, move_end, part_num)
end if

&lt;&lt; Impose periodic boundary conditions &gt;&gt;

&lt;&lt; Update move type statistics &gt;&gt;

&lt;&lt; Update the displacement matrix &gt;&gt;
</t>
<t tx="gcross.20090626112946.1689">if( present(pbc_period_length) ) then
  call vpi_update_xij_pbc( xij2_trial, q_trial, move_start, move_end, N_SLICES, N_PARTICLES, N_DIMENSIONS  )
else
  call vpi_update_xij( xij2_trial, q_trial, move_start, move_end, N_SLICES, N_PARTICLES, N_DIMENSIONS  )
end if
</t>
<t tx="gcross.20090626112946.1690">slice_move_attempted_counts(move_start:move_end) =  slice_move_attempted_counts(move_start:move_end) + 1
move_type_attempted_counts(mtype) = move_type_attempted_counts(mtype) + 1
</t>
<t tx="gcross.20090626112946.1691">if( present(pbc_period_length) ) then
  q_trial(move_start:move_end,:,:) = wrap_around(q_trial(move_start:move_end,:,:))
end if
</t>
<t tx="gcross.20090626112946.1693">&lt;&lt; Compute logarithmic probability of acceptance &gt;&gt;

&lt;&lt; Accept or reject the move &gt;&gt;

</t>
<t tx="gcross.20090626112946.1694">subroutine thermalize_path( &amp;
  q, xij2, U, gradU2, &amp;
  N_SLICES, N_PARTICLES, N_DIMENSIONS, &amp;
  n_trials, &amp;
  slice_move_attempted_counts, move_type_attempted_counts, &amp;
  slice_move_accepted_counts, move_type_accepted_counts, &amp;  
  q_rot, N_DIMENSIONS_ROTATION, &amp;
  pbc_period_length &amp;
  )

  ! Input variables
  integer, intent(in) :: N_SLICES, N_PARTICLES, N_DIMENSIONS, n_trials
  integer, intent(in), optional :: N_DIMENSIONS_ROTATION
  double precision, intent(in), optional :: pbc_period_length

  ! Updated variables
  double precision, dimension( N_SLICES, N_PARTICLES, N_DIMENSIONS ), intent(inout) :: q
  double precision, dimension( :, :, : ), intent(inout), optional :: q_rot
  double precision, dimension( N_SLICES, N_PARTICLES, N_PARTICLES ), intent(inout) :: xij2
  double precision, dimension( N_SLICES, N_PARTICLES ), intent(inout) :: U
  double precision, dimension( N_SLICES ), intent(inout) :: gradU2
  integer, dimension( N_SLICES ), intent(inout) :: slice_move_attempted_counts, slice_move_accepted_counts
  integer, dimension( N_MOVE_TYPES ), intent(inout) :: move_type_attempted_counts, move_type_accepted_counts

  ! Local variables
  integer :: i, mtype, move_start, move_end, part_num
  double precision :: old_weight, new_weight
  logical :: reject_flag
  double precision, dimension( N_SLICES, N_PARTICLES, N_DIMENSIONS ) :: q_trial
  double precision, dimension( :, :, : ), allocatable :: q_rot_trial
  double precision, dimension( N_SLICES, N_PARTICLES, N_PARTICLES ), intent(inout) :: xij2_trial
  double precision, dimension( N_SLICES, N_PARTICLES ) :: U_trial
  double precision, dimension( N_SLICES ) :: gradU2_trial

  &lt;&lt; Initialize trial functions &gt;&gt;

  do i = 1, n_trials
    &lt;&lt; Randomly choose a move to make and apply it to the system &gt;&gt;

    &lt;&lt; Determine whether the move should be accepted &gt;&gt;
  end do

  if( allocated( q_rot_trial ) ) then
    deallocate( q_rot_trial )
  end if

  contains

  @others

end subroutine thermalize_path
</t>
<t tx="gcross.20090626112946.1696">call compute_physical_potential (&amp;
    x, xij2, x_rot, &amp;
    move_start, move_end, &amp;
    nslice, np, ndim, &amp;
    U, gradU2, &amp;
    reject_flag &amp;
    )

if (reject_flag) then
  return
endif

if (fixed_angular_momentum &gt; 0) then
  call compute_effective_rotational_potential (&amp;
    x, &amp;
    move_start, move_end, &amp;
    nslice, np, ndim, &amp;
    U &amp;
    )
end if

U_total =&gt; U

</t>
<t tx="gcross.20090626112946.1701">q(move_start:move_end,:,:) = q_trial(move_start:move_end,:,:)
if( present(q_rot) ) then
  q_rot(move_start:move_end,:,:) = q_rot_trial(move_start:move_end,:,:)
end if
</t>
<t tx="gcross.20090626112946.1703">slice_move_accepted_counts(move_start:move_end) =  slice_move_accepted_counts(move_start:move_end) + 1
move_type_accepted_counts(mtype) = move_type_accepted_counts(mtype) + 1
</t>
<t tx="gcross.20090626112946.1706">if ( accept_path( old_weight, new_weight, 1.0D0 ) ) then
  &lt;&lt; Update the degrees of freedom &gt;&gt;
  &lt;&lt; Update derived quantities &gt;&gt;
  &lt;&lt; Update statistics &gt;&gt;
else
  call revert_move
end if
</t>
<t tx="gcross.20090721121051.1746">function compute_log_acceptance_weight (&amp;
! INPUT: particle position / rotation information
    x, xij2, x_rot, &amp;
! INPUT: path slice to consider
    move_start, move_end, &amp;
! INPUT: 
    nslice, np, ndim, &amp;
! OUTPUT: potential and square gradients
    U, gradU2, &amp;
! OUTPUT: whether the move should be rejected outright
    reject_flag &amp;
! OUTPUT: computed weight
    ) result ( weight )

@
Array dimensions / slicing
@c
  integer, intent(in) :: move_start, move_end, nslice, np, ndim

@
Function input
@c

  double precision, dimension ( nslice, np , ndim ), intent(in) :: x
  double precision, dimension ( nslice, np , np ), intent(in) :: xij2
  double precision, dimension ( nslice, np , N_DIM_ROT ), intent(in) :: x_rot

@
Function output
@c
  double precision, dimension( nslice, np ), target, intent(out) :: U
  double precision, dimension( nslice ), intent(out) :: gradU2
  double precision :: weight
  logical, intent(out) :: reject_flag

@
Temporary variables.
@c
  double precision, dimension( nslice, np ), target :: U_effective
  double precision, dimension( :, : ), pointer :: U_total
  double precision :: lngfn, rotgfn, hsgfn, lntfn
  integer :: sl_start, sl_end
@
Code begins:
@c
  &lt;&lt; Compute contribution from potentials &gt;&gt;

  &lt;&lt; Compute contribution from propagators &gt;&gt;

  &lt;&lt; Compute contribution from trial functions &gt;&gt;

  weight = lngfn + lntfn

  return

end function
</t>
<t tx="gcross.20090721121051.1752">if(move_start .le. 1) then
  sl_start = 1
else
  sl_start = move_start-1
end if
if(move_end .ge. N_SLICE) then
  sl_end = N_SLICE
else
  sl_end = move_end+1
end if

if( n_slice &gt; 2 ) then 
  if ( use_gfn4 ) then
    lngfn = vpi_gfn4_sp( sl_start, sl_end, part_num, U_total, gradU2, U_weight, gU2_weight, &amp;
                         N_SLICE, N_PARTICLE, N_DIM, lambda, dtau ) 
  else 
    lngfn = vpi_gfn2_sp( sl_start, sl_end, part_num, U_total, N_SLICE, N_PARTICLE, N_DIM, dtau ) 
  end if

@
  if ( use_HS_gfn ) then
#ifdef USE_IMAGE_HSGFN
    hsgfn = vpi_hs_gfn( sl_start, sl_end, part_num, xij2, N_SLICE, N_PARTICLE, N_DIM, dtau*lambda )
#else
    hsgfn = vpi_hs_gfn2( sl_start, sl_end, part_num, x, N_SLICE, N_PARTICLE, N_DIM, dtau*lambda )
#endif
    if( hsgfn &lt;= 0 .and. hsgfn1 &gt; 0 ) then
      print *, "****ERROR***** hsgfn &lt; 0 ", hsgfn0, hsgfn1
    else
      lngfn = lngfn + log(hsgfn)
    else
  end if
@c

  if ( use_HW_gfn ) then
    hsgfn = vpi_hw_gfn( sl_start, sl_end, part_num, x, N_SLICE, N_PARTICLE, N_DIM, dtau )
    lngfn = lngfn + log(hsgfn)
  end if

  if ( eval_rotation ) then
    rotgfn =  gfn_rot(x_rot,part_num,sl_start,sl_end,dtau)
!          write (1000+my_rank,*) rotgfn
    lngfn = lngfn + log(rotgfn)
  end if
end if

</t>
<t tx="gcross.20090721121051.1754">lntfn = tfunc(x, 1, N_SLICE, N_PARTICLE, N_DIM) + &amp;
        tfunc(x, N_SLICE, N_SLICE, N_PARTICLE, N_DIM) + &amp;
        jas_tfun(x, xij2, 1, N_SLICE, N_PARTICLE, N_DIM) + &amp;
        jas_tfun(x, xij2, N_SLICE, N_SLICE, N_PARTICLE, N_DIM)
</t>
<t tx="gcross.20090721121051.1755">old_weight = compute_log_acceptance_weight (&amp;
    q, xij2, q_rot_trial, &amp;
    move_start, move_end, &amp;
    n_slices, n_particles, n_dimensions, &amp;
    U, gradU2, &amp;
    reject_flag &amp;
    )

if(reject_flag) then
  stop "Error:  A path that had been okay before is somehow invalid now."
end if

new_weight = compute_log_acceptance_weight (&amp;
    q_trial, xij2_trial, q_rot_trial, &amp;
    move_start, move_end, &amp;
    n_slices, n_particles, n_dimensions, &amp;
    U_trial, gradU2_trial, &amp;
    reject_flag &amp;
    )

if(reject_flag) then
  call revert_move
  cycle
end if
</t>
<t tx="gcross.20090805093617.1831">xij2(move_start:move_end,:,:) = xij2_trial(move_start:move_end,:,:) 
U(move_start:move_end,:) = U_trial(move_start:move_end,:)
gradU2(move_start:move_end) = gradU2_trial(move_start:move_end)
</t>
<t tx="gcross.20090805093617.1835">subroutine revert_move
  q_trial(move_start:move_end,:,:) = q(move_start:move_end,:,:)
  if( eval_rotation ) then
    q_rot_trial(move_start:move_end,:,:) = q_rot(move_start:move_end,:,:)
  end if
  xij2_trial(move_start:move_end,:,:) = xij2(move_start:move_end,:,:)
  U_trial(move_start:move_end,:) = U(move_start:move_end,:)
  gradU2_trial(move_start:move_end) =  gradU2(move_start:move_end)
end subroutine revert_move
</t>
<t tx="gcross.20090805153643.1848">q_trial = q
if( present(q_rot) ) then
  allocate( q_rot_trial( N_SLICES, N_PARTICLES, N_DIMENSIONS ) )
  q_rot_trial = q_rot
end if
xij2_trial = xij2
U_trial = U
gradU2_trial = gradU2</t>
<t tx="gcross.20090807144330.1670"></t>
<t tx="gcross.20090807144330.1673"></t>
<t tx="gcross.20090809223137.1725">@language fortran90
@tabwidth -2
</t>
<t tx="gcross.20090809223137.1726"></t>
</tnodes>
</leo_file>
